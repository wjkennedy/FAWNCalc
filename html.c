/*	html.c

	Code to generate HTML output
*/

#include <stdarg.h>

#include "rules.h"


#define	MIN(a,b)	(((a)<(b))?(a):(b))
#define	MAX(a,b)	(((a)>(b))?(a):(b))

#define row_start() fprintf(cgiOut, "<tr>\n");
#define row_end()   fprintf(cgiOut, "</tr>\n");
#define print_hidden(name,fmt,value) \


static void print_hidden_fields(void);
static void print_login(void);
static void print_nics(void);
static void print_cabs(void);
static void print_sw(void);
static void print_proc(void);
static void print_moms(void);
static void print_mems(void);
static void print_disks(void);
static void print_kases(void);
static void print_racks(void);
static void print_bundles(void);

extern char *cgiRepeatQ(char *addon);

static void
header(char *s, ...)
{
	va_list ap;

	va_start(ap, s);
	fprintf(cgiOut,
		"<STYLE TYPE=\"text/css\" MEDIA=\"screen, projection\"> @import url(fawncalc.css)\;</STYLE>\n"
		"<html>\n"
		"<head>\n"
		"<link href=\"http://beta.a9group.net/fawncalc/fawncalc.css\" type=\"text/css\"/>\n"
        );
	vfprintf(cgiOut, s, ap);
	fprintf(cgiOut,
		"</head>\n"
		"<body>\n"
		"<h1>\n"
		"<p>\n");
	vfprintf(cgiOut, s, ap);
	fprintf(cgiOut,
		"</h1>\n"
		"<p>\n");
	va_end(ap);

/*
	fprintf(cgiOut, "To repeat this request, click <A\n");
	fprintf(cgiOut, "href=\"%s\"\n", cgiRepeatQ(""));
	fprintf(cgiOut, ">here</a>.<p>\n");
*/
}

static void
trailer(void)
{
	fprintf(cgiOut,
		"<hr>\n"
		"<p>\n"
		"<br><br><br><br>\n"
		"<a href=\"http://beta.a9group.net/fawncalc/fawncalc.cgi\"><IMG SRC=\""LOGO_URL"\" WIDTH=150 HEIGHT=30 ALT=\"FAWN Calc\"</a>\n"
		"</body>\n"
		"</html>\n");
	fflush(cgiOut);
}

/* print form for anonymous or logged in designs */
void print_eval_form(void)
{
	header("");
	fprintf(cgiOut,
		"<FORM METHOD=\"POST\" ACTION=\""CDR_EXEC"\">\n");
	print_hidden_fields();
	fprintf(cgiOut,
        "<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>"
		"<hr><h2>Costs &AMP; Internal Parameters</h2>\n"
		"<p>\n"
		"This tool strives to present a selection of COTS development and production"
		"systems for ARM Family devices"
		"The full set of cost and internal parameters used by the CGI\n"
		"is stored in a database.  You can select any of these parameter sets,\n"
		"some of which have been made available by other users, or create one\n"
		"with your own values to better reflect your circumstances.  \n"
        "<br><info><a href=http://dev.fawncalc.beta.a9group.net/docs/db/>See the docs on the database here</a></info>"
/* 
                "If you have previously created your own parameter set and chosen to keep it\n"
		"private, enter your email address and password to use your custom\n"
		"parameter set." 
*/
		"<p>\n");
	/* insert list of databases here */
	print_options();
	fprintf(cgiOut,
		"<INPUT TYPE=SUBMIT VALUE=\"View "
        "Set\" NAME=\"view_params\">\n");
	if (g_uid < 0) {
		print_login();
	} else {
		fprintf(cgiOut,
			"<INPUT TYPE=SUBMIT VALUE=\"Edit %s's parameter set "
			"starting with the parameter set selected above\" "
			"NAME=\"edit_params\">\n", email);
	}
	fprintf(cgiOut,
		"<hr><p>\n"
		"\n"
		"This form contains a series of questions about your clustered application and constraints on the cluster design.  A CGI program will use your answers to provide a set of cluster designs that might be appropriate for your application. The search space is generally very large, so the CGI limits the search time to 10 seconds.  Of course, the designs generated by the CGI should be treated only as a starting point for your own detailed design analysis.\n"
		"<hr><h2>Memory</h2>\n"
		"<p>\n"
		"\n"
		"Although data size often increases somewhat when a program is parallelized (due to copies buffered to avoid communication), the memory space that would be taken by your serial program's data for the largest problem you hope to solve can be used as an estimate of the data space needed in parallel execution.\n"
		"In integer MB, about how much data does your program need to hold in main memory?\n"
		"\n"
		"<BR>\n"
		"<select name=\"datasize\">\n"
		"<option value=\"1\">1MB or less\n"
		"<option value=\"2\">1MB to 2MB\n"
		"<option value=\"4\">2MB to 4MB\n"
		"<option value=\"8\">4MB to 8MB\n"
		"<option value=\"16\">8MB to 16MB\n"
		"<option value=\"32\">16MB to 32MB\n"
		"<option value=\"64\">32MB to 64MB\n"
		"<option value=\"128\">64MB to 128MB\n"
		"<option value=\"256\">128MB to 256MB\n"
		"<option value=\"512\">256MB to 512MB\n"
		"<option value=\"1024\">512MB to 1GB\n"
		"<option value=\"2048\">1GB to 2GB\n"
		"<option value=\"4096\">2GB to 4GB\n"
		"<option value=\"8192\">4GB to 8GB\n"
		"<option value=\"16384\">8GB to 16GB\n"
		"<option value=\"32768\">16GB to 32GB\n"
		"<option value=\"65536\">32GB to 64GB\n"
		"<option value=\"131072\">64GB to 128GB\n"
		"<option value=\"262144\">128GB to 256GB\n"
		"<option value=\"524288\">256GB to 512GB\n"
		"<option value=\"1048576\">512GB to 1TB\n"
		"<option value=\"2097152\">1TB to 2TB\n"
		"<option value=\"4194304\">2TB to 4TB\n"
		"</select>\n per cluster"
		"<p>\n"
		"\n"
		"Your application program will need to be running on each node,\n"
		"thus, each node memory will need a copy of the executable code.\n"
		"Not counting data, how big is your compiled program?\n"
		"\n"
		"<BR>\n"
		"<select name=\"codesize\">\n"
		"<option value=\"1\">1MB or less\n"
		"<option value=\"2\">1MB to 2MB\n"
		"<option value=\"4\">2MB to 4MB\n"
		"<option value=\"8\">4MB to 8MB\n"
		"<option value=\"16\">8MB to 16MB\n"
		"<option value=\"32\">16MB to 32MB\n"
		"<option value=\"64\">32MB to 64MB\n"
		"<option value=\"128\">64MB to 128MB\n"
		"<option value=\"256\">128MB to 256MB\n"
		"<option value=\"512\">256MB to 512MB\n"
		"<option value=\"1024\">512MB to 1GB\n"
		"<option value=\"2048\">1GB to 2GB\n"
		"</select> per node\n"
		"<p>\n"
		"\n"
		"Operating systems differ, but any OS you use on each node will\n"
		"have to fit in node memory.  This OS memory use includes not\n"
		"just the OS kernel, but also any background OS tasks and a\n"
		"reasonable set of I/O buffers.  How much main memory will your\n"
		"OS use on each node?\n"
		"\n"
		"<BR>\n"
		"<select name=\"ossize\">\n"
		"<option value=\"16\">16MB (e.g., minimal Linux)\n"
		"<option value=\"32\">32MB (e.g., Linux + X Windows)\n"
		"<option value=\"64\">64MB (e.g., minimal MS Windows)\n"
		"<option value=\"128\">128MB\n"
		"<option value=\"256\">256MB\n"
		"<option value=\"512\">512MB\n"
		"<option value=\"1024\">1GB\n"
		"<option value=\"2048\">2GB\n"
		"</select> per node\n"
		"<p>\n"
		"\n"
		"Ever since cache moved on-chip, cache bandwidth has been very\n"
		"good for most processors.  Unfortunately, codes that have\n"
		"cache-unfriendly memory access patterns are very sensitive to\n"
		"main memory bandwidth.  If you specify a particular memory\n"
		"bandwidth (GBytes/second per GFLOPS) here, the GFLOPS rating\n"
		"quoted for each design will be limited to the GFLOPS supported\n"
		"by the memory bandwidth of the system.\n"
		"\n"
		"<BR>\n"
		"<select name=\"minmemgbs\">\n"
		"<option value=\"0.1\">my code is very cache-friendly\n"
		"<option value=\"0.125\">0.125GB/s per GFLOPS\n"
		"<option value=\"0.25\">0.25GB/s per GFLOPS\n"
		"<option value=\"0.5\">0.5GB/s per GFLOPS\n"
		"<option value=\"0.75\">0.75GB/s per GFLOPS\n"
		"<option value=\"1.0\">1.0GB/s per GFLOPS\n"
		"<option value=\"1.25\">1.25GB/s per GFLOPS\n"
		"<option value=\"1.5\">1.5GB/s per GFLOPS\n"
		"<option value=\"2.0\">2.0GB/s per GFLOPS\n"
		"<option value=\"3.0\">3.0GB/s per GFLOPS\n"
		"<option value=\"4.0\">4.0GB/s per GFLOPS\n"
		"<option value=\"8.0\">8.0GB/s per GFLOPS\n"
		"<option value=\"16.0\">16.0GB/s per GFLOPS\n"
		"<option value=\"32.0\">32.0GB/s per GFLOPS\n"
		"</select>\n"
		"\n"
		"<hr><h2>Hard Disk Drives</h2>\n"
		"<p>\n"
		"\n"
		"Although use of disk-based virtual memory should be avoided to\n"
		"achieve maximum performance, many existing software packages\n"
		"have \"memory leaks\" that make their memory image slowly grow\n"
		"despite the fact that the memory space they are truly using does\n"
		"not grow.  If your code leaks, you may want to use local disks\n"
		"for virtual memory swap space.  How much swap space should be\n"
		"allocated?\n"
		"\n"
		"<BR>\n"
		"<select name=\"swapsize\">\n"
		"<option value=\"0\">no virtual memory swap space\n"
		"<option value=\"1\">swap same size as main memory\n"
		"<option value=\"2\">swap 2X main memory size\n"
		"<option value=\"3\">swap 3X main memory size\n"
		"<option value=\"4\">swap 4X main memory size\n"
		"</select>\n"
		"<p>\n"
		"\n"
		"In total, how many GB of hard disk storage do you need for live\n"
		"data in your cluster?  (Keep in mind that your cluster can\n"
		"borrow disk space from other machines, so no disk is needed\n"
		"within the cluster nodes.)\n"
		"\n"
		"<BR>\n"
		"<select name=\"disksize\">\n"
		"<option value=\"0\">none within the cluster nodes\n"
		"<option value=\"2\">2GB or less\n"
		"<option value=\"4\">2GB to 4GB\n"
		"<option value=\"8\">4GB to 8GB\n"
		"<option value=\"16\">8GB to 16GB\n"
		"<option value=\"32\">16GB to 32GB\n"
		"<option value=\"64\">32GB to 64GB\n"
		"<option value=\"128\">64GB to 128GB\n"
		"<option value=\"256\">128GB to 256GB\n"
		"<option value=\"512\">256GB to 512GB\n"
		"<option value=\"1024\">512GB to 1TB\n"
		"<option value=\"2048\">1TB to 2TB\n"
		"<option value=\"4096\">2TB to 4TB\n"
		"<option value=\"8192\">4TB to 8TB\n"
		"<option value=\"16384\">8TB to 16TB\n"
		"<option value=\"32768\">16TB to 32TB\n"
		"<option value=\"65536\">32TB to 64TB\n"
		"<option value=\"131072\">64TB to 128TB\n"
		"<option value=\"262144\">128TB to 256TB\n"
		"<option value=\"524288\">256TB to 512TB\n"
		"<option value=\"1048576\">512TB to 1PB\n"
		"</select>\n"
		"<p>\n"
		"\n"
		"One of the advantages of clusters is that you can use additional\n"
		"disk drives in each node to increase reliability (using simple\n"
		"disk mirroring or fancier RAID techniques) or to hold backups.\n"
		"Which of these techniques do you intend to use?\n"
		"\n"
		"<BR>\n"
		"<INPUT TYPE=RADIO NAME=\"useraid\" VALUE=\"0\" CHECKED> no RAID\n"
		"<INPUT TYPE=RADIO NAME=\"useraid\" VALUE=\"1\"> add RAID for recovery from one disk failure\n"
		"<BR>\n"
		"<INPUT TYPE=RADIO NAME=\"usebackup\" VALUE=\"0\" CHECKED> no extra disk space\n"
		"<INPUT TYPE=RADIO NAME=\"usebackup\" VALUE=\"1\"> add space for a backup copy\n"
		"<p>\n"
		"\n"
		"<hr><h2>Network</h2>\n"
		"<p>\n"
		"\n"
		"The minimum message latency of the network plays a major role in\n"
		"determining the finest grain parallelism you can use across the\n"
		"nodes of a cluster.  What is the largest minimum latency that\n"
		"you expect your code can tolerate?\n"
		"\n"
		"<BR>\n"
		"<select name=\"maxlatency\">\n"
		"<option value=\"100\">50 to 100 microseconds\n"
		"<option value=\"50\">10 to 50 microseconds\n"
		"<option value=\"10\">10 microseconds or less\n"
		"<option value=\"1000000\">latency is not a concern\n"
		"<option value=\"3200\">1600 to 3200 microseconds\n"
		"<option value=\"1600\">800 to 1600 microseconds\n"
		"<option value=\"800\">400 to 800 microseconds\n"
		"<option value=\"400\">200 to 400 microseconds\n"
		"<option value=\"200\">100 to 200 microseconds\n"
		"</select>\n"
		"<p>\n"
		"\n"
		"Latency in performing various types of aggregate functions (aka,\n"
		"collective communications) is different from latency on\n"
		"point-to-point messages.  What is the largest minimum latency\n"
		"that you expect your code can tolerate on aggregate operations\n"
		"like barrier synchronization?\n"
		"\n"
		"<BR>\n"
		"<select name=\"afnlatency\">\n"
		"<option value=\"1000000\">latency is not a concern\n"
		"<option value=\"3200\">1600 to 3200 microseconds\n"
		"<option value=\"1600\">800 to 1600 microseconds\n"
		"<option value=\"800\">400 to 800 microseconds\n"
		"<option value=\"400\">200 to 400 microseconds\n"
		"<option value=\"200\">100 to 200 microseconds\n"
		"<option value=\"100\">50 to 100 microseconds\n"
		"<option value=\"50\">10 to 50 microseconds\n"
		"<option value=\"10\">10 microseconds or less\n"
		"</select>\n"
		"<p>\n"
		"\n"
		"Bisection bandwidth is a very important in achieving good\n"
		"performance from some applications, but is relatively\n"
		"unimportant for others.  If all the processors in the cluster\n"
		"are communicating simultaneously, what is the minimum amount of\n"
		"network bandwidth that must be available to each processor?\n"
		"(I.e., what is bisection bandwidth / number of processor?)\n"
		"\n"
		"<BR>\n"
		"<select name=\"minbandwidth\">\n"
		"<option value=\"100\">90Mb/s to 100Mb/s\n"
		"<option value=\"125\">100Mb/s to 125Mb/s\n"
		"<option value=\"150\">125Mb/s to 150Mb/s\n"
		"<option value=\"175\">150Mb/s to 175Mb/s\n"
		"<option value=\"200\">175Mb/s to 200Mb/s\n"
		"<option value=\"250\">200Mb/s to 250Mb/s\n"
		"<option value=\"300\">250Mb/s to 300Mb/s\n"
		"<option value=\"350\">300Mb/s to 350Mb/s\n"
		"<option value=\"400\">350Mb/s to 400Mb/s\n"
		"<option value=\"500\">400Mb/s to 500Mb/s\n"
		"<option value=\"550\">500Mb/s to 550Mb/s\n"
		"<option value=\"600\">550Mb/s to 600Mb/s\n"
		"<option value=\"601\">more than 600Mb/s\n"
		"<option value=\"0\">0 (only one node talks at a time)\n"
		"<option value=\"10\">10Mb/s or less\n"
		"<option value=\"20\">10Mb/s to 20Mb/s\n"
		"<option value=\"30\">20Mb/s to 30Mb/s\n"
		"<option value=\"40\">30Mb/s to 40Mb/s\n"
		"<option value=\"50\">40Mb/s to 50Mb/s\n"
		"<option value=\"60\">50Mb/s to 60Mb/s\n"
		"<option value=\"70\">60Mb/s to 70Mb/s\n"
		"<option value=\"80\">70Mb/s to 80Mb/s\n"
		"<option value=\"90\">80Mb/s to 90Mb/s\n"
		"</select>\n"
		"<p>\n"
		"\n"
		"When a node needs to communicate, on average, how many other\n"
		"nodes does it need to talk with?  We call this number the\n"
		"<EM>coordinality</EM> of communication.  For example, to update\n"
		"boundary regions in a simple 2D grid code, each node typically\n"
		"communicates with every node that is handling an adjacent\n"
		"portion of the 2D space; thus, communication would involve 4\n"
		"other nodes.\n"
		"\n"
		"<BR>\n"
		"<select name=\"coordinality\">\n"
		"<option value=\"6\">more than 5 other nodes\n"
		"<option value=\"1000\">all other nodes\n"
		"<option value=\"0\">0 (nodes never communicate)\n"
		"<option value=\"1\">1 other node\n"
		"<option value=\"2\">2 other nodes\n"
		"<option value=\"3\">3 other nodes\n"
		"<option value=\"4\">4 other nodes\n"
		"<option value=\"5\">5 other nodes\n"
		"</select>\n"
		"<p>\n"
		"\n"
		"<hr><h2>Physical Parameters</h2>\n"
		"<p>\n"
		"\n"
		"No matter how reliable your vendors are, even if you have a maintenance\n"
		"contract, you <EM>need</EM> spare nodes.  Without spares, hardware failures\n"
		"not only will take time to be repaired, but also probably will result in your\n"
		"hardware becoming heterogeneous, because identical parts are no longer\n"
		"available.  \"Hot\" spares give you higher availability than \"cold\" spares, but\n"
		"increase your network costs.  How many spare nodes do you want to include?\n"
		"\n"
		"<BR>\n"
		"<select name=\"sparen0\">\n"
		"<option value=\"1\"> cold spares, 1 for every\n"
		"<option value=\"0\"> hot spares, 1 for every\n"
		"<option value=\"3\"> cold spares, exactly\n"
		"<option value=\"2\"> hot spares, exactly\n"
		"</select>\n"
		"<INPUT TYPE=\"TEXT\" NAME=\"sparen1\" VALUE=\"16\">\n"
		"<p>\n"
		"\n"
		"Not counting spares, does your cluster need to have a specific number of nodes or processors?\n"
		"What are the constraints?\n"
		"\n"
		"<BR>\n"
		"<select name=\"nodecon0\">\n"
		"<option value=\"0\"> number of nodes\n"
		"<option value=\"1\"> number of processors\n"
		"</select>\n"
		"<select name=\"nodecon1\">\n"
		"<option value=\"0\">is unconstrained\n"
		"<option value=\"1\">must be a power of 2\n"
		"<option value=\"2\">must be a square\n"
		"<option value=\"3\">must be a cube\n"
		"<option value=\"4\">must be exactly\n"
		"</select>\n"
		"<INPUT TYPE=\"TEXT\" NAME=\"nodecon2\" VALUE=\"\">\n"
		"<p>\n"
		"\n"
		"The cluster nodes and switches need to be mounted in some kind\n"
		"of rack or shelving unit.  A typical rack needs about 2x2 feet\n"
		"of floor space; shelving units come in various sizes, but most\n"
		"require about 2x4 feet of floor space (i.e., roughly the space\n"
		"of two 2x2 racks).  Allowing at least a 2 foot wide path to walk\n"
		"around the racks, what is the maximum number of 2x2 rack units\n"
		"that you can fit in the space you have available?\n"
		"\n"
		"<BR>\n"
		"<select name=\"racks\">\n"
		"<option value=\"1000000\">rack space is not an issue\n"
		"<option value=\"1\">1 rack\n"
		"<option value=\"2\">2 racks\n"
		"<option value=\"3\">3 racks\n"
		"<option value=\"4\">4 racks\n"
		"<option value=\"5\">5 racks\n"
		"<option value=\"6\">6 racks\n"
		"<option value=\"7\">7 racks\n"
		"<option value=\"8\">8 racks\n"
		"<option value=\"9\">9 racks\n"
		"<option value=\"10\">10 racks\n"
		"<option value=\"11\">11 racks\n"
		"<option value=\"12\">12 racks\n"
		"<option value=\"13\">13 racks\n"
		"<option value=\"14\">14 racks\n"
		"<option value=\"15\">15 racks\n"
		"<option value=\"16\">16 racks\n"
		"<option value=\"17\">17 racks\n"
		"<option value=\"18\">18 racks\n"
		"<option value=\"19\">19 racks\n"
		"<option value=\"20\">20 racks\n"
		"<option value=\"21\">21 racks\n"
		"<option value=\"22\">22 racks\n"
		"<option value=\"23\">23 racks\n"
		"<option value=\"24\">24 racks\n"
		"<option value=\"25\">25 racks\n"
		"<option value=\"26\">26 racks\n"
		"<option value=\"27\">27 racks\n"
		"<option value=\"28\">28 racks\n"
		"<option value=\"29\">29 racks\n"
		"<option value=\"30\">30 racks\n"
		"<option value=\"31\">31 racks\n"
		"<option value=\"32\">32 racks\n"
		"<option value=\"33\">33 racks\n"
		"<option value=\"34\">34 racks\n"
		"<option value=\"35\">35 racks\n"
		"<option value=\"36\">36 racks\n"
		"<option value=\"37\">37 racks\n"
		"<option value=\"38\">38 racks\n"
		"<option value=\"39\">39 racks\n"
		"<option value=\"40\">40 racks\n"
		"<option value=\"41\">41 racks\n"
		"<option value=\"42\">42 racks\n"
		"<option value=\"43\">43 racks\n"
		"<option value=\"44\">44 racks\n"
		"<option value=\"45\">45 racks\n"
		"<option value=\"46\">46 racks\n"
		"<option value=\"47\">47 racks\n"
		"<option value=\"48\">48 racks\n"
		"<option value=\"49\">49 racks\n"
		"<option value=\"50\">50 racks\n"
		"</select>\n"
		"<p>\n"
		"\n"
		"Power requirements for nodes vary depending on the precise\n"
		"contents of the nodes, but a large cluster needs a lot of power.\n"
		"In the USA, that power is typically 110VAC, usually with a 15A\n"
		"or 20A limit on each circuit coming from the main power box.\n"
		"Approximately how much 110VAC power can be dedicated to the\n"
		"cluster?\n"
		"\n"
		"<BR>\n"
		"<select name=\"amps\">\n"
		"<option value=\"1000000\">power is not an issue\n"
		"<option value=\"5\">5A to 10A\n"
		"<option value=\"10\">10A to 15A\n"
		"<option value=\"15\">15A to 20A\n"
		"<option value=\"20\">20A to 25A\n"
		"<option value=\"25\">25A to 30A\n"
		"<option value=\"30\">30A to 40A\n"
		"<option value=\"40\">40A to 50A\n"
		"<option value=\"50\">50A to 60A\n"
		"<option value=\"60\">60A to 70A\n"
		"<option value=\"70\">70A to 80A\n"
		"<option value=\"80\">80A to 90A\n"
		"<option value=\"90\">90A to 100A\n"
		"<option value=\"100\">100A to 120A\n"
		"<option value=\"120\">120A to 140A\n"
		"<option value=\"140\">140A to 160A\n"
		"<option value=\"160\">160A to 180A\n"
		"<option value=\"180\">180A to 200A\n"
		"<option value=\"200\">200A to 220A\n"
		"<option value=\"220\">220A to 240A\n"
		"<option value=\"240\">240A to 260A\n"
		"<option value=\"260\">260A to 280A\n"
		"<option value=\"280\">280A to 300A\n"
		"<option value=\"300\">300A to 350A\n"
		"<option value=\"350\">350A to 400A\n"
		"<option value=\"400\">400A to 450A\n"
		"<option value=\"450\">450A to 500A\n"
		"<option value=\"500\">500A to 600A\n"
		"<option value=\"600\">600A to 700A\n"
		"<option value=\"700\">700A to 800A\n"
		"<option value=\"800\">800A to 900A\n"
		"<option value=\"900\">900A to 1000A\n"
		"<option value=\"1000\">1000A to 1200A\n"
		"<option value=\"1200\">1200A to 1400A\n"
		"<option value=\"1400\">1400A to 1600A\n"
		"<option value=\"1600\">1600A to 1800A\n"
		"<option value=\"1800\">1800A to 2000A\n"
		"<option value=\"2000\">2000A to 2500A\n"
		"<option value=\"2500\">2500A to 3000A\n"
		"<option value=\"3000\">3000A to 3500A\n"
		"<option value=\"3500\">3500A to 4000A\n"
		"<option value=\"4000\">4000A to 4500A\n"
		"<option value=\"4500\">4500A to 5000A\n"
		"</select>\n"
		"<p>\n"
		"\n"
		"<p>Essentially all the power consumed by a cluster gets\n"
		"turned into heat, which has to be removed from the\n"
		"room housing the cluster.  How much air conditioning is\n"
		"available in the cluster room?\n"
		"\n"
		"<BR>\n"
		"<select name=\"tons\">\n"
		"<option value=\"1000000\">Air Conditioning is not a factor\n"
		"<option value=\"0.25\">0.25tons to 0.5tons\n"
		"<option value=\"0.5\">0.5tons to 0.75tons\n"
		"<option value=\"0.75\">0.75tons to 1.0tons\n"
		"<option value=\"1.0\">1.0tons to 1.5tons\n"
		"<option value=\"1.5\">1.5tons to 2.0tons\n"
		"<option value=\"2.0\">2.0tons to 2.5tons\n"
		"<option value=\"2.5\">2.5tons to 3.0tons\n"
		"<option value=\"3.0\">3.0tons to 3.5tons\n"
		"<option value=\"3.5\">3.5tons to 4.0tons\n"
		"<option value=\"4.0\">4.0tons to 5.0tons\n"
		"<option value=\"5.0\">5.0tons to 7.5tons\n"
		"<option value=\"7.5\">7.5tons to 10.0tons\n"
		"<option value=\"10.0\">10tons to 15tons\n"
		"<option value=\"15.0\">15tons to 20tons\n"
		"<option value=\"20.0\">20tons to 25tons\n"
		"<option value=\"25.0\">25tons to 30tons\n"
		"<option value=\"30.0\">30tons to 50tons\n"
		"<option value=\"50.0\">50tons to 75tons\n"
		"<option value=\"75.0\">75tons to 100tons\n"
		"<option value=\"100.0\">100tons to 125tons\n"
		"<option value=\"125.0\">125tons to 150tons\n"
		"<option value=\"150.0\">150tons to 175tons\n"
		"</select>\n"
		"<p>\n"
		"\n"
		"<hr><h2>Metrics</h2>\n"
		"<p>\n"
		"\n"
		"What is your budget for the cluster?  Be somewhat conservative,\n"
		"because there are always a few unexpected costs.\n"
		"\n"
		"<BR>\n"
		"<INPUT TYPE=\"TEXT\" NAME=\"budget\" VALUE=\"10000\">\n"
		"<p>\n"
		"\n"
		"What is the minimum number of GFLOPS your cluster must be able\n"
		"to achieve?\n"
		"\n"
		"<BR>\n"
		"<INPUT TYPE=\"TEXT\" NAME=\"gflops\" VALUE=\"50\">\n"
		"<p>\n"
		"\n"
		"What is the maximum number of designs that should be displayed?\n"
		"\n"
		"<BR>\n"
		"<select name=\"howmany\">\n"
		"<option value=\"256\">the best 256 designs\n"
		"<option value=\"512\">the best 512 designs\n"
		"<option value=\"1024\">the best 1024 designs\n"
		"<option value=\"2048\">the best 2048 designs\n"
		"<option value=\"4096\">the best 4096 designs\n"
		"<option value=\"8192\">the best 8192 designs\n"
		"<option value=\"1\">only the best design\n"
		"<option value=\"2\">the best 2 designs\n"
		"<option value=\"4\">the best 4 designs\n"
		"<option value=\"8\">the best 8 designs\n"
		"<option value=\"16\">the best 16 designs\n"
		"<option value=\"32\">the best 32 designs\n"
		"<option value=\"64\">the best 64 designs\n"
		"<option value=\"128\">the best 128 designs\n"
		"</select>\n"
		"<p>\n"
		"\n"
		"There are a variety of metrics computed for each feasible\n"
		"configuration.  The following parameters allow you to set\n"
		"weightings for how these metrics will be combined to determine\n"
		"the sorted order of configurations, and hence which design is\n"
		"best.  Weightings are multiplicative factors; higher factors\n"
		"imply that extra performance is more important in that metric.\n"
		"\n"
		"<BR>\n"
		"<select name=\"metmem\">\n"
		"<option value=\"0\">0 * Memory space\n"
		"<option value=\"1\">1 * Memory space\n"
		"<option value=\"10\">10 * Memory space\n"
		"<option value=\"100\">100 * Memory space\n"
		"<option value=\"1000\">1000 * Memory space\n"
		"<option value=\"10000\">10000 * Memory space\n"
		"<option value=\"100000\">100000 * Memory space\n"
		"<option value=\"1000000\">1000000 * Memory space\n"
		"</select> +\n"
		"<select name=\"metmemgbs\">\n"
		"<option value=\"0\">0 * Memory bandwidth\n"
		"<option value=\"1\">1 * Memory bandwidth\n"
		"<option value=\"10\">10 * Memory bandwidth\n"
		"<option value=\"100\">100 * Memory bandwidth\n"
		"<option value=\"1000\">1000 * Memory bandwidth\n"
		"<option value=\"10000\">10000 * Memory bandwidth\n"
		"<option value=\"100000\">100000 * Memory bandwidth\n"
		"<option value=\"1000000\">1000000 * Memory bandwidth\n"
		"</select> +\n"
		"<select name=\"metdisk\">\n"
		"<option value=\"0\">0 * Disk space\n"
		"<option value=\"1\">1 * Disk space\n"
		"<option value=\"10\">10 * Disk space\n"
		"<option value=\"100\">100 * Disk space\n"
		"<option value=\"1000\">1000 * Disk space\n"
		"<option value=\"10000\">10000 * Disk space\n"
		"<option value=\"100000\">100000 * Disk space\n"
		"<option value=\"1000000\">1000000 * Disk space\n"
		"</select> +\n"
		"<select name=\"metlat\">\n"
		"<option value=\"0\">0 * 1/Net latency\n"
		"<option value=\"1\">1 * 1/Net latency\n"
		"<option value=\"10\">10 * 1/Net latency\n"
		"<option value=\"100\">100 * 1/Net latency\n"
		"<option value=\"1000\">1000 * 1/Net latency\n"
		"<option value=\"10000\">10000 * 1/Net latency\n"
		"<option value=\"100000\">100000 * 1/Net latency\n"
		"<option value=\"1000000\">1000000 * 1/Net latency\n"
		"</select> +\n"
		"<select name=\"metbw\">\n"
		"<option value=\"0\">0 * Net bandwidth\n"
		"<option value=\"1\">1 * Net bandwidth\n"
		"<option value=\"10\">10 * Net bandwidth\n"
		"<option value=\"100\">100 * Net bandwidth\n"
		"<option value=\"1000\">1000 * Net bandwidth\n"
		"<option value=\"10000\">10000 * Net bandwidth\n"
		"<option value=\"100000\">100000 * Net bandwidth\n"
		"<option value=\"1000000\">1000000 * Net bandwidth\n"
		"</select> +\n"
		"<select name=\"metcost\">\n"
		"<option value=\"0\">0 * 1/Cost\n"
		"<option value=\"1\">1 * 1/Cost\n"
		"<option value=\"10\">10 * 1/Cost\n"
		"<option value=\"100\">100 * 1/Cost\n"
		"<option value=\"1000\">1000 * 1/Cost\n"
		"<option value=\"10000\">10000 * 1/Cost\n"
		"<option value=\"100000\">100000 * 1/Cost\n"
		"<option value=\"1000000\">1000000 * 1/Cost\n"
		"</select> +\n"
		"<select name=\"metgflops\">\n"
		"<option value=\"1\">1 * GFLOPS\n"
		"<option value=\"10\">10 * GFLOPS\n"
		"<option value=\"100\">100 * GFLOPS\n"
		"<option value=\"1000\">1000 * GFLOPS\n"
		"<option value=\"10000\">10000 * GFLOPS\n"
		"<option value=\"100000\">100000 * GFLOPS\n"
		"<option value=\"1000000\">1000000 * GFLOPS\n"
		"<option value=\"0\">0 * GFLOPS\n"
		"</select> +\n"
		"<select name=\"metamps\">\n"
		"<option value=\"0\">0 * Amps\n"
		"<option value=\"1\">1 * 1/Amps\n"
		"<option value=\"10\">10 * 1/Amps\n"
		"<option value=\"100\">100 * 1/Amps\n"
		"<option value=\"1000\">1000 * 1/Amps\n"
		"<option value=\"10000\">10000 * 1/Amps\n"
		"<option value=\"100000\">100000 * 1/Amps\n"
		"<option value=\"1000000\">1000000 * 1/Amps\n"
		"</select> +\n"
		"<select name=\"mettons\">\n"
		"<option value=\"0\">0 * Tons\n"
		"<option value=\"1\">1 * 1/Tons\n"
		"<option value=\"10\">10 * 1/Tons\n"
		"<option value=\"100\">100 * 1/Tons\n"
		"<option value=\"1000\">1000 * 1/Tons\n"
		"<option value=\"10000\">10000 * 1/Tons\n"
		"<option value=\"100000\">100000 * 1/Tons\n"
		"<option value=\"1000000\">1000000 * 1/Tons\n"
		"</select>\n"
		"<p>\n"
		"<hr><h2>Component Limitations</h2>\n"
		"<p>For non-technical reasons, you may be restricted to including\n"
		"certain components with or excluding certain components from your\n"
		"cluster.  You may limit the search to either include or exclude\n"
		"systems that have a particular string in the name or type of at least\n"
		"one component.\n"
		"<p>\n"
		"Include only designs with \n"
		"\n"
		"<select name=\"include_logic\">\n"
		"<option value=0>any\n"
		"<option value=1>all\n"
		"</select> \n"
		"\n"
		"of the space separated strings below in the name or type of at least\n"
		"one component. Surround strings that have spaces with quotes (e.g.,\n"
		"\"Fast Ethernet\"). \n"
		"<br>\n"
		"<input type=\"text\" name=\"include_str\" value=\"\" size=\"50\" maxlength=4000>\n"
		"<p>\n"
		"Exclude all designs with \n"
		"\n"
		"<select name=\"exclude_logic\">\n"
		"<option value=0>any\n"
		"<option value=1>all\n"
		"</select> \n"
		"\n"
		"of the space separated strings below in the name or type of at least\n"
		"one component.  Surround strings that have spaces with quotes (e.g.,\n"
		"\"Fast Ethernet\").\n"
		"<br><input type=\"text\" name=\"exclude_str\" value=\"\" size=\"50\" maxlength=4000>\n"
		"<p>\n"
		"<INPUT TYPE=SUBMIT VALUE=\"Submit Constraints\" NAME=\"eval_design\">\n"
		"<INPUT TYPE=RESET VALUE=\"Reset Form\">\n"
		"<p>\n"
		"</FORM>\n"
		"<p>");
	trailer();
}

static void print_login(void)
{
	fprintf(cgiOut,
		"<p>To edit your own parameter set you must first login.\n"
		"You need not\n"
		"login to evaluate a design using any of the parameter sets\n"
		"that appear above.  If you are unsure, you\n"
		"probably do not need to login.\n"
		"<p>\n"
        "<div>"
		"<a href=\"http://beta.a9group.net/fawncalc/fawncalc.cgi\"><IMG SRC=\""LOGO_URL"\"></a>\n"
        "<h4>\n"
		"Email address:\n"
        "</h4>\n"
		"<INPUT TYPE=\"TEXT\" NAME=\"email\" VALUE=\"\" SIZE=\"40\"\n"
		"MAXLENGTH=4000>\n"
        "<h4>\n"
		"Password:\n"
        "</h4>\n"
		"<INPUT TYPE=\"PASSWORD\" NAME=\"password\" VALUE=\"\" \n"
		"SIZE=10 MAXLENGTH=4000>\n"
        "<br>"
		"<INPUT TYPE=\"SUBMIT\" VALUE=\"Login\" NAME=\"login\">\n"
        "</div>"
		"<p>\n"
		"If you would like to login, you must first\n"
		"<a href=\"fawncalc.cgi?new_user_form=1\">create a new user account</a>\n"
		"if you have not done so before.\n"
		"Each email address is allowed one parameter set\n"
		);
}

static void print_hidden_fields(void)
{
	print_hidden("version", "%d", VERSION);
	print_hidden("timeout", "%d", MAX_SECS);
	if (g_uid > 0) {
		print_hidden("email", "%s", email);
		print_hidden("password", "%s", password);
	}
	fprintf(cgiOut, "\n"); 
}

void print_params(void) 
{
	char buf[MAXLEN];

	snprintf(buf, MAXLEN, "<br>Parameter Set \"%s\"", dbname);
	header(buf);

	fprintf(cgiOut, "<p>Parameter set \"%s\" was created by %s\n<p>",
		dbname, dbemail);
	get_passwd(dbemail, buf, MAXLEN);
	if (is_expired(buf)) {
		fprintf(cgiOut, "<p><STRONG>This parameter set is expired.\n"
			"Others will not be able to evaluate it, and it may\n"
			"be removed if it is not updated soon.</STRONG>\n"
			"Edit and save this parameter set to restore it\n"
			"to normal status\n");
			
	}
	if (oread || (strcmp(dbemail, email) == 0)) {
		fprintf(cgiOut, "<p>\n%s", viewcomment);
		fprintf(cgiOut,
			"<hr><h2>Permissions</h2>\n"
			"Other users can%s evaluate designs based on\n"
			"this parameter set\n",
			oeval ? "" : "not");
		fprintf(cgiOut,
			"Other users can%s view this parameter set\n"
			"<p>",
			oread ? "" : "not");
		print_nics();
		print_cabs();
		print_sw();
		print_proc();
		print_moms();
		print_mems();
		print_disks();
		print_kases();
		print_racks();
		print_bundles();
	} else {
		fprintf(cgiOut,
			"The creator of this parameter set has chosen not\n"
			"to let others view the costs\n"
			"and internal parameters they have selected.\n"
			"Please contact %s to inquire about this\n"
			"parameter set\n", dbemail);
	}
	trailer();
}

void eval_denied(void)
{
	char title[MAXLEN];

	snprintf(title, MAXLEN, "Cannot Evaluate Design with Parameter Set \"%s\"", dbname);
	header(title);

	fprintf(cgiOut, "<p>Parameter set \"%s\" was created by %s\n<p>",
		dbname, dbemail);

	fprintf(cgiOut,
		"The creator of this parameter set has chosen not\n"
		"to let others evalutate designs based on the costs\n"
		"and internal parameters they have selected.\n"
		"Please contact %s to inquire about this\n"
		"parameter set\n", dbemail);
}

static void print_nics(void)
{
	int  nic;

	fprintf(cgiOut,
		"<H3>NICs (PCI bus network interface cards)</H3>\n"
		"<TABLE BORDER>\n"
		"<tr>\n"
		"<TH ALIGN=LEFT>Name</TH>\n"
		"<TH ALIGN=LEFT>Network Type</TH>\n"
		"<TH ALIGN=LEFT>Bandwidth (Mb/s)</TH>\n"
		"<TH ALIGN=LEFT>Latency (us)</TH>\n"
		"<TH ALIGN=LEFT>Cost</TH>\n"
		"</tr>\n");
	for (nic = 0 ; nic < nic_opts ; nic++) {
		row_start();
		fprintf(cgiOut, "<td>%s</td><td>%s</td>"
			"<td>%g</td><td>%g</td><td>%g</td>\n",
			nic_opt[nic].name, nic_opt[nic].ntype,
			nic_opt[nic].mbs, nic_opt[nic].us, nic_opt[nic].cost);
		row_end();
	}
	fprintf(cgiOut,
		"</tr>\n"
		"\n"
		"\n"
		"</TABLE>\n"
		"<p>\n");
}

static void print_cabs(void)
{
	int cab;

	fprintf(cgiOut,
		"<H3>Network Cables</H3>\n"
		"<TABLE BORDER>\n"
		"<tr>\n"
		"<TH ALIGN=LEFT>Name</TH>\n"
		"<TH ALIGN=LEFT>Network Type</TH>\n"
		"<TH ALIGN=LEFT>Length (feet)</TH>\n"
		"<TH ALIGN=LEFT>Cost</TH>\n"
		"</tr>\n");
	for (cab = 0 ; cab < cab_opts ; cab++) {
		row_start();
		fprintf(cgiOut, "<td>%s</td><td>%s</td><td>%g</td><td>%g</td>\n",
			cab_opt[cab].name, cab_opt[cab].ntype,
			cab_opt[cab].feet, cab_opt[cab].cost);
		row_end();
	}
	fprintf(cgiOut,
		"</TABLE>\n"
		"<p>\n");
}

static void print_sw(void)
{
	int sw;

	fprintf(cgiOut,
		"<H3>Switches (network switches)</H3>\n"
		"<TABLE BORDER>\n"
		"<tr>\n"
		"<TH ALIGN=LEFT>Name</TH>\n"
		"<TH ALIGN=LEFT>Network Type</TH>\n"
		"<TH ALIGN=LEFT>Total Bandwidth (Mb/s)</TH>\n"
		"<TH ALIGN=LEFT>Latency (us)</TH>\n"
		"<TH ALIGN=LEFT># Ports</TH>\n"
		"<TH ALIGN=LEFT>Cost</TH>\n"
		"<TH ALIGN=LEFT>Size (in U)</TH>\n"
		"<TH ALIGN=LEFT>Power (in Amps)</TH>\n"
		"</tr>\n");
	for (sw = 0 ; sw < sw_opts ; sw++) {
		row_start();
		fprintf(cgiOut, "<td>%s</td><td>%s</td><td>%g</td><td>%g</td>"
			"<td>%d</td><td>%g</td><td>%d</td><td>%g</td>\n",
			sw_opt[sw].name, sw_opt[sw].ntype, sw_opt[sw].mbs,
			sw_opt[sw].us, sw_opt[sw].ports, sw_opt[sw].cost,
			sw_opt[sw].u, sw_opt[sw].amps);
		row_end();
	}
	fprintf(cgiOut,
		"</TABLE>\n"
		"<p>\n");
}

static void print_proc(void)
{
	int proc;

	fprintf(cgiOut,
		"<H3>Processors</H3>\n"
		"<TABLE BORDER>\n"
		"<tr>\n"
		"<TH ALIGN=LEFT>Name</TH>\n"
		"<TH ALIGN=LEFT>Processor Type</TH>\n"
		"<TH ALIGN=LEFT>GFLOPS</TH>\n"
		"<TH ALIGN=LEFT>Cost</TH>\n"
		"</tr>\n");

	for (proc = 0 ; proc < proc_opts ; proc++) {
		row_start();
		fprintf(cgiOut, "<td>%s</td><td>%s</td><td>%g</td><td>%g</td>\n",
			proc_opt[proc].name, proc_opt[proc].ptype,
			proc_opt[proc].gflops, proc_opt[proc].cost);
		row_end();
	}
	fprintf(cgiOut,
		"</TABLE>\n"
		"<p>\n");
}

static void print_moms(void)
{
	int mom;

	fprintf(cgiOut,
		"<H3>Motherboards</H3>\n"
		"<TABLE BORDER>\n"
		"<tr>\n"
		"<TH ALIGN=LEFT>Name</TH>\n"
		"<TH ALIGN=LEFT>Processor Type</TH>\n"
		"<TH ALIGN=LEFT>Memory Type</TH>\n"
		"<TH ALIGN=LEFT>Case Type</TH>\n"
		"<TH ALIGN=LEFT># Processor Sockets</TH>\n"
		"<TH ALIGN=LEFT># Memory Slots</TH>\n"
		"<TH ALIGN=LEFT># PCI Slots</TH>\n"
		"<TH ALIGN=LEFT># IDE Drives</TH>\n"
		"<TH ALIGN=LEFT>Has PXE</TH>\n"
		"<TH ALIGN=LEFT>Cost</TH>\n"
		"</tr>\n");
	for (mom = 0 ; mom < mom_opts ; mom++) {
		row_start();
		fprintf(cgiOut, "<td>%s</td><td>%s</td><td>%s</td><td>%s</td>"
			"<td>%d</td><td>%d</td><td>%d</td><td>%d</td><td>%s</td><td>%g</td>",
			mom_opt[mom].name, mom_opt[mom].ptype,
			mom_opt[mom].mtype, mom_opt[mom].ctype,
			mom_opt[mom].n, mom_opt[mom].mem, mom_opt[mom].pci,
			mom_opt[mom].ide, mom_opt[mom].pxe ? "Y" : "N", mom_opt[mom].cost);
		row_end();
	}
	fprintf(cgiOut,
		"</TABLE>\n"
		"<p>\n");
}

static void print_mems(void)
{
	int mem;

	fprintf(cgiOut,
		"<H3>Memory Parts</H3>\n"
		"<TABLE BORDER>\n"
		"<tr>\n"
		"<TH ALIGN=LEFT>Name</TH>\n"
		"<TH ALIGN=LEFT>Memory Type</TH>\n"
		"<TH ALIGN=LEFT>Size (in MB)</TH>\n"
		"<TH ALIGN=LEFT>Bandwidth (in GB/s)</TH>\n"
		"<TH ALIGN=LEFT>Cost</TH>\n"
		"</tr>\n");

	for (mem = 0 ; mem < mem_opts ; mem++) {
		row_start();
		fprintf(cgiOut, "<td>%s</td><td>%s</td>"
			"<td>%g</td><td>%g</td><td>%g</td>\n",
			mem_opt[mem].name, mem_opt[mem].mtype,
			mem_opt[mem].mb, mem_opt[mem].gbs, mem_opt[mem].cost);
		row_end();
	}
	fprintf(cgiOut,
		"</TABLE>\n"
		"<p>\n");
}

static void print_disks(void)
{
	int disk;

	fprintf(cgiOut,
		"<H3>Disk Drives (or other netboot devices)</H3>\n"
		"<TABLE BORDER>\n"
		"<tr>\n"
		"<TH ALIGN=LEFT>Name</TH>\n"
		"<TH ALIGN=LEFT>Size (in GB)</TH>\n"
		"<TH ALIGN=LEFT>Cost</TH>\n"
		"</tr>\n");
	for (disk = 0 ; disk < disk_opts ; disk++) {
		row_start();
		fprintf(cgiOut, "<td>%s</td><td>%g</td><td>%g</td>\n",
			disk_opt[disk].name, disk_opt[disk].gb,
			disk_opt[disk].cost);
		row_end();
	}
	fprintf(cgiOut,
		"</TABLE>\n"
		"<p>\n");
}

static void print_kases(void)
{
	int kase;

	fprintf(cgiOut,
		"<H3>Cases (stand-alone or rack mount)</H3>\n"
		"<TABLE BORDER>\n"
		"<tr>\n"
		"<TH ALIGN=LEFT>Name</TH>\n"
		"<TH ALIGN=LEFT>Case Type</TH>\n"
		"<TH ALIGN=LEFT>Rack Type</TH>\n"
		"<TH ALIGN=LEFT># IDE Drives</TH>\n"
		"<TH ALIGN=LEFT>Cost</TH>\n"
		"<TH ALIGN=LEFT>Size (in U)</TH>\n"
		"<TH ALIGN=LEFT>Power (in Amps)</TH>\n"
		"</tr>\n");
	for (kase = 0 ; kase < kase_opts ; kase++) {
		row_start();
		fprintf(cgiOut, "<td>%s</td><td>%s</td><td>%s</td>"
			"<td>%d</td><td>%g</td><td>%d</td><td>%g</td>\n",
			kase_opt[kase].name, kase_opt[kase].ctype,
			kase_opt[kase].rtype, kase_opt[kase].ide,
			kase_opt[kase].cost, kase_opt[kase].u,
			kase_opt[kase].amps);
		row_end();
	}
	fprintf(cgiOut,
		"</TABLE>\n"
		"<p>\n");
}

static void print_racks(void)
{
	int rack;

	fprintf(cgiOut,
		"<H3>Racks (shelving units or rack cabinets)</H3>\n"
		"<TABLE BORDER>\n"
		"<tr>\n"
		"<TH ALIGN=LEFT>Name</TH>\n"
		"<TH ALIGN=LEFT>Rack Type</TH>\n"
		"<TH ALIGN=LEFT>Cost</TH>\n"
		"<TH ALIGN=LEFT>Size (in U)</TH>\n"
		"<TH ALIGN=LEFT>Floorspace (in 2x2')</TH>\n"
		"</tr>\n");
	for (rack = 0 ; rack < rack_opts ; rack++) {
		row_start();
		fprintf(cgiOut, "<td>%s</td><td>%s</td><td>%g</td>"
			"<td>%d</td><td>%d</td>\n",
			rack_opt[rack].name, rack_opt[rack].rtype,
			rack_opt[rack].cost, rack_opt[rack].u,
			rack_opt[rack].floor);
		row_end();
	}
	fprintf(cgiOut,
		"</TABLE>\n"
		"<p>\n");
}

#define BUNDLE_PART_NM_QTY(part) { \
	if (bundle_opt[bundle]. part##_qty > 0) { \
		fprintf(cgiOut, "<td>%s</td><td>%d</td>", \
			part##_opt[bundle_opt[bundle]. part].name, \
			bundle_opt[bundle]. part##_qty); \
	} else { \
		fprintf(cgiOut, "<td>&nbsp;</td><td>&nbsp;</td>"); \
	} \
}

static void print_bundles(void)
{
	int bundle;

	fprintf(cgiOut,
		"<H3>Bundles of Other Parts</H3>\n"
		"<TABLE BORDER>\n"
		"<tr>\n"
		"<TH ALIGN=LEFT>Name</TH>\n"
		"<TH ALIGN=LEFT>NIC</TH>\n"
		"<TH ALIGN=LEFT>Qty.</TH>\n"
		"<TH ALIGN=LEFT>Network Cables</TH>\n"
		"<TH ALIGN=LEFT>Qty.</TH>\n"
		"<TH ALIGN=LEFT>Switches</TH>\n"
		"<TH ALIGN=LEFT>Qty.</TH>\n"
		"<TH ALIGN=LEFT>Processors</TH>\n"
		"<TH ALIGN=LEFT>Qty.</TH>\n"
		"<TH ALIGN=LEFT>Motherboards</TH>\n"
		"<TH ALIGN=LEFT>Qty.</TH>\n"
		"<TH ALIGN=LEFT>Memory</TH>\n"
		"<TH ALIGN=LEFT>Qty.</TH>\n"
		"<TH ALIGN=LEFT>Disks</TH>\n"
		"<TH ALIGN=LEFT>Qty.</TH>\n"
		"<TH ALIGN=LEFT>Cases</TH>\n"
		"<TH ALIGN=LEFT>Qty.</TH>\n"
		"<TH ALIGN=LEFT>Racks</TH>\n"
		"<TH ALIGN=LEFT>Qty.</TH>\n"
		"<TH ALIGN=LEFT>Bundle Cost</TH>\n"
		"</tr>\n");
	for (bundle = 0 ; bundle < bundle_opts ; bundle++) {
		row_start();
		fprintf(cgiOut, "<td>%s</td>", bundle_opt[bundle].name);
		BUNDLE_PART_NM_QTY(nic);
		BUNDLE_PART_NM_QTY(cab);
		BUNDLE_PART_NM_QTY(sw);
		BUNDLE_PART_NM_QTY(proc);
		BUNDLE_PART_NM_QTY(mom);
		BUNDLE_PART_NM_QTY(mem);
		BUNDLE_PART_NM_QTY(disk);
		BUNDLE_PART_NM_QTY(kase);
		BUNDLE_PART_NM_QTY(rack);
		fprintf(cgiOut, "<td>%g</td>\n", bundle_opt[bundle].cost);
		row_end();
	}
	fprintf(cgiOut,
		"</TABLE>\n"
		"<p>\n");
}


static char whybuf[1024];

char *
whystuck(void)
{
	switch (stuck_at) {
	case SA_EVAL0: return("the node count constraint left no designs viable.");
	case SA_EVAL1: return("no motherboards were viable choices.");
	  /* num processors eval'd */
	case SA_EVAL2: return("all bundled designs that meet your GFLOPS requirement exceed your budget.");
	case SA_EVAL3: return("all designs that meet your GFLOPS requirement exceed your budget.");
	case SA_NET0: return("no networks were viable choices.");
	  /* num processors and network eval'd */
	case SA_NET1: return("all designs that meet your networking and GFLOPS "
			     "requirements exceed your budget.");
	case SA_CAB0: return("no cables were available for wiring the network.");
	  /* num processors, network, and cables eval'd */
	case SA_CAB1: return("all designs that meet your networking and GFLOPS "
			     "requirements exceed your budget.");
	case SA_PROC0: return("no processors were viable choices.");
	case SA_PROC1: return("no numbers of processors/motherboard were viable choices.");
	case SA_PROC2: return("could not achieve sufficient network bandwidth for a viable design.");
	case SA_PROC3: return("could not achieve sufficient GFLOPS for a viable design.");
	  /* num processors, network, cables, proc type, and motherboard eval'd */
	case SA_PROC4: return("all designs that meet your networking and GFLOPS "
			      "requirements exceed your budget.");
	case SA_MEM0: return("no memory parts were viable choices.");
	case SA_MEM1: return("no numbers of memory parts/motherboard were viable choices.");
	case SA_MEM2: return("memory part bandwidth is not sufficient to create a viable design.");
	case SA_MEM3: return("memory part size is too small to create a viable design.");
	  /* num processors, network, cables, proc type, motherboard, mem eval'd */
	case SA_MEM4: return("all designs that meet your networking, GFLOPS, and "
			     "memory requirements exceed your budget.");
	case SA_KASE0: return("no cases were viable choices.");
	case SA_AMPS0: return("there was not enough power for any otherwise viable design.");
	case SA_TONS0: return("there was not enough air conditioning capacity for any otherwise viable design.");
	case SA_RACK0: return("no rack or shelving systems were viable choices.");
	case SA_RACK1: return("there was not enough floorspace for any otherwise viable design.");
	  /* num processors, network, cables, proc type, motherboard, mem, kase eval'd */
	case SA_RACK2: return("all designs that meet your networking, GFLOPS, "
			      "memory, power, and floorspace requirements "
			      "exceed your budget.");
	case SA_DISK0: return("no disk drives were viable choices.");
	case SA_DISK1: return("no numbers of disk drives/node were viable choices.");
	  /* num processors, network, cables, proc type, motherboard, mem, kase, disk eval'd */
	case SA_DISK2: return("all designs that meet your networking, GFLOPS, "
			      "memory, power, floorspace, and disk "
			      "requirements exceed your budget.");
	case SA_COST0:
		sprintf(whybuf,
			"no viable design cost less than your budget (cheapest was $%.2f).",
			cheapest);
		return(whybuf);
	}
	
	return("an internal error occurred in the CGI program.");
}

void
whatnet(register designt *p)
{
	if (p->net_type == NET_NONE) {
		fprintf(cgiOut, "No network was needed.\n");
		return;
	}
	
	fprintf(cgiOut, "This design is a %d+%d node configuration\n", p->n, p->spares);
	if ((p->spares == 0) || (p->n != p->nodes)) {
		fprintf(cgiOut, "in which all nodes are interconnected by\n");
	} else {
		fprintf(cgiOut, "in which non-spare nodes are interconnected by\n");
	}
	
	switch (p->net_type & (NET_CB | NET_FNN)) {
	case NET_CB:
		fprintf(cgiOut, "a Channel Bonded (CB) network using\n");
		break;
	case NET_FNN:
	case (NET_CB | NET_FNN):
		fprintf(cgiOut, "a Flat Neighborhood Network (FNN) using\n");
		break;
	}

	switch (p->net_type & (NET_DIRECT | NET_SWITCH | NET_FABRIC | NET_RING | NET_2DMESH | NET_3DMESH)) {
	case NET_DIRECT:
		fprintf(cgiOut, "direct connections between machines.\n");
		break;
	case NET_RING:
		fprintf(cgiOut, "a ring routing through machines.\n");
		break;
	case NET_2DMESH:
		fprintf(cgiOut, "a 2D wrap-around %dx%d mesh routing through machines.\n",
			p->net_x,
			p->net_y);
		break;
	case NET_3DMESH:
		fprintf(cgiOut, "a 3D wrap-around %dx%dx%d mesh routing through machines.\n",
			p->net_x,
			p->net_y,
			p->net_z);
		break;
	case NET_SWITCH:
		fprintf(cgiOut, "a single switch layer between machines.\n");
		break;
	default:
		fprintf(cgiOut, "a multi-hop switch fabric between machines.\n");
	}
}

#define	BARSIZE	250

static void
bar(register char *tag,
    register int min,
    register int val,
    register int max)
{
	register int pos;

	fprintf(cgiOut, "<tr><TH WIDTH=100 ALIGN=LEFT>%-26s  ", tag);
	if (min == max) {
		fprintf(cgiOut, "<td ALIGN=RIGHT>%-10d  ", val);
		fprintf(cgiOut, "<td ALIGN=RIGHT>%10d"
			"<td ><hr><td> %-10d</tr>\n", min, max);
	} else {
		fprintf(cgiOut, "<td ALIGN=RIGHT>%-10d  ", val);
		fprintf(cgiOut, "<td ALIGN=RIGHT>%10d ", min);
		pos = (((val - min) * ((BARSIZE - 3.0) / (max - min))) + 0.5);
		fprintf(cgiOut, "<td><TABLE BORDER><tr><td WIDTH=%d>"
			"<td BGCOLOR=blue>&nbsp;<td WIDTH=%d></tr></TABLE>",
			pos, BARSIZE-pos);
		fprintf(cgiOut, "<td>%-10d</tr>\n", max);
	}
}

static void
dbar(register char *tag,
     register double min,
     register double val,
     register double max)
{
	register int pos;

	fprintf(cgiOut, "<tr><TH ALIGN=LEFT>%-26s  ", tag);
	if (min == max) {
		fprintf(cgiOut, "<td ALIGN=RIGHT>%-10.2f  ", val);
		fprintf(cgiOut, "<td ALIGN=RIGHT>%10.2f"
			"<td ><hr><td> %-10.2f</tr>\n", min, max);
	} else {
		fprintf(cgiOut, "<td ALIGN=RIGHT>%-10.2f  ", val);
		fprintf(cgiOut, "<td ALIGN=RIGHT>%10.2f ", min);
		pos = (((val - min) * ((BARSIZE - 3.0) / (max - min))) + 0.5);
		fprintf(cgiOut, "<td><TABLE BORDER><tr><td WIDTH=%d>"
			"<td BGCOLOR=blue>&nbsp;<td WIDTH=%d></tr></TABLE>",
			pos, BARSIZE-pos);
		fprintf(cgiOut, "<td>%-10.2f</tr>\n", max);
	}
}


#define	MINANDMAX(field) \
	if (p->field < min->field) { min->field = p->field; } \
	else { if (p->field > max->field) max->field = p->field; }

static int got_minandmax = 0;

static void
minandmax(void)
{
	/* Compute min & max for all solution fields */
	register designt *min = (dp + 1);
	register designt *max = (dp + 2);
	register designt *p;

	if (got_minandmax) return;

	*min = (*max = design[0]);
	for (p=&(design[1]); p<dp; ++p) {
		MINANDMAX(n)
			MINANDMAX(nodes)
			MINANDMAX(spares)
			MINANDMAX(nics)
			MINANDMAX(cabs)
			MINANDMAX(sws)
			MINANDMAX(sw2s)
			MINANDMAX(procs)
			MINANDMAX(moms)
			MINANDMAX(mems)
			MINANDMAX(disks)
			MINANDMAX(kases)
			MINANDMAX(racks)
			MINANDMAX(nicpnode)
			MINANDMAX(procpmom)
			MINANDMAX(mempmom)
			MINANDMAX(diskpnode)
			MINANDMAX(usrgflops)
			MINANDMAX(usrmem)
			MINANDMAX(usrmemgbs)
			MINANDMAX(usrdisk)
			MINANDMAX(usramps)
			MINANDMAX(usrtons)
			MINANDMAX(net_latency)
			MINANDMAX(net_bandwidth)
			MINANDMAX(cost)
			MINANDMAX(metric)
			}

	/* No need to do this again... */
	got_minandmax = 1;
}


#define TOTAL_PARTS(val,ptr,part) \
{ \
	int bund; \
\
	val = (ptr)->part##s;\
	for(bund = 0 ; bund < (ptr)->bundles ; bund++) {\
		val += (ptr)->bundle[bund].n * bundle_opt[(ptr)->bundle[bund].id]. part##_qty;\
	}\
}

#define	BAR(name, field) \
	bar(name, (dp+1)->field, q->field, (dp+2)->field)

#define	DBAR(name, field) \
	dbar(name, (dp+1)->field, q->field, (dp+2)->field)

static void
relgraph(register designt *q)
{
	/* Output simple HTML graphics... */
	fprintf(cgiOut, "<TABLE WIDTH=90%%>\n"
		"<COL WIDTH=25%%>"
		"<COL WIDTH=12%%>"
		"<COL WIDTH=15%%>"
		"<COL WIDTH=30%%>"
		"<COL WIDTH=5%%");
	BAR("Powered nodes", nodes);
	if (q->n == q->nodes) {
		BAR("Cold spares", spares);
	} else {
		BAR("Compute nodes", n);
		BAR("Hot spares", spares);
	}
	BAR("NICs", dnics);
	BAR("Cables", dcabs);
	bar("Switches",
	    ((dp+1)->dsws + (dp+1)->dsw2s),
	    (q->dsws + q->dsw2s),
	    ((dp+2)->dsws + (dp+2)->dsw2s));
	BAR("Processors", dprocs);
	BAR("Motherboards", dmoms);
	BAR("Disk drives", ddisks);
	BAR("Cases", dkases);
	BAR("Racks", dracks);
	BAR("NICs/node", nicpnode);
	BAR("Processors/node", procpmom);
	DBAR("Usable GFLOPS", usrgflops);
	DBAR("Usable memory (MB)", usrmem);
	DBAR("GB/s per (GFLOPS)", usrmemgbs);
	DBAR("Usable disk (GB)", usrdisk);
	DBAR("Total amps", usramps);
	DBAR("Air Conditioning (tons)", usrtons);
	DBAR("Network latency (us)", net_latency);
	DBAR("Network bandwidth (Mb/s)", net_bandwidth);
	DBAR("Total cost", cost);
	fprintf(cgiOut,
		"</TABLE>\n"
		"<p>\n");
}

static void
stats(void)
{
	register int best, i;


	fprintf(cgiOut,
		"<p>\n"
		"Over all %d viable designs, the following components were most commonly used:\n"
		"<UL>\n",
		designs_ok);

#define	STATS(field) \
	best = 0; \
	for (i=1; ((i<MAXOPTS) && (field##_opt[i].name)); ++i) { \
		if (field##_opt[i].estat > field##_opt[best].estat) { \
			best = i; \
		} \
	} \
	if (field##_opt[best].estat > 0) { \
		fprintf(cgiOut, \
"<LI>\n" \
"%.2f%% used %s\n", \
		((field##_opt[best].estat * 100.0) / designs_ok), \
		field##_opt[best].name); \
	}

	STATS(nic);
	STATS(cab);
	STATS(sw);
	STATS(proc);
	STATS(mom);
	STATS(mem);
	STATS(disk);
	STATS(kase);
	STATS(rack);

	fprintf(cgiOut, "</UL>\n");
}


static void
notes(register designt *p)
{
	if (((p->net_type & NET_FNN) == 0) &&
	    (p->sw2s == 0)) return;

	fprintf(cgiOut,
		"<p>\n"
		"<H3>Notes</H3>\n"
		"<OL>\n");

	/* Notes about fabrics */
	if (p->sw2s > 0) {
		fprintf(cgiOut,
			"<LI>\n"
			"Fabric-based designs do not require that all switches be identical.\n"
			"For a tree fabric, the best bandwidth is achieved when the top switch (%s)\n"
			"is at least a wide as each of the bottom switches (%s).\n",
			sw_opt[p->sw].name,
			sw_opt[p->sw2].name);

		if (p->sw2s < sw_opt[p->sw].ports) {
			fprintf(cgiOut,
				"This particular fabric is not a complete tree,\n"
				"but all ports of the %d-way top switch should be used;\n"
				"i.e., some nodes connect directly to the top-level switch.\n",
				sw_opt[p->sw].ports);
		}
	}

	/* Notes about FNNs */
	if (p->net_type & NET_FNN) {
		fprintf(cgiOut,
			"<LI>\n"
			"Due to the complexity and asymetry of FNN designs,\n"
			"a heuristic is used to compute very approximate FNN bisection bandwidth.\n");

		if (p->net_type & NET_FABRIC) {
			fprintf(cgiOut,
				"Because switch fabrics are used in this design, latency is higher than for a true FNN.\n"
				"Similarly, bandwidth is limited by the top switches in the tree fabrics within the FNN.\n");
		} else if (coordinality < p->nicpnode) {
			fprintf(cgiOut,
				"Further, because your application has relatively low coordinality, you may need\n"
				"FNN \"advanced routing\" software (still under development) to achieve the best performance.\n");
		}
	}

	fprintf(cgiOut,
		"</OL>\n");
}

void 
out_space_stats(void)
{
	if (searchdone) {
		fprintf(cgiOut,
			"The entire configuration space using the "
			"\"%s\" database was searched.  \n",
			dbname);
	} else {
		fprintf(cgiOut,
			"<STRONG><FONT COLOR=RED>The search using the "
			"\"%s\" database was truncated after %d "
			"seconds.</FONT></STRONG>\n<p>\n",
			dbname, searchsecs);
	}
	fprintf(cgiOut, "<p>\n%s\n</P>\n", evalcomment);


}

#define BUNDLE_CONTENTS(idx,part) { \
	if (bundle_opt[p->bundle[idx].id]. part##_qty > 0) { \
		fprintf(cgiOut, "(%d) %s, ", bundle_opt[p->bundle[idx].id]. part##_qty, \
			part##_opt[bundle_opt[p->bundle[idx].id]. part].name); \
	} \
}

void out_bundle_contents(designt *p)
{
	int i;

	fprintf(cgiOut, "<p>Bundles used in this design are:\n<UL>\n");
	for(i = 0 ; i < p->bundles ; i++) {
		fprintf(cgiOut, "<LI> %s: ", bundle_opt[p->bundle[i].id].name);
		BUNDLE_CONTENTS(i, nic);
		BUNDLE_CONTENTS(i, cab);
		BUNDLE_CONTENTS(i, sw);
		BUNDLE_CONTENTS(i, proc);
		BUNDLE_CONTENTS(i, mom);
		BUNDLE_CONTENTS(i, mem);
		BUNDLE_CONTENTS(i, disk);
		BUNDLE_CONTENTS(i, kase);
		BUNDLE_CONTENTS(i, rack);
	}
	fprintf(cgiOut, "</UL>\n");
}

#define	tablerow(quant, field, optfield) \
		if (quant > 0 && p->field >= 0) { \
			fprintf(cgiOut, \
"<tr>\n" \
"<td ALIGN=RIGHT>%d</td>\n" \
"<td ALIGN=LEFT>%s</td>\n" \
"<td ALIGN=RIGHT>$%.2f</td>\n" \
"<td ALIGN=RIGHT>$%.2f</td>\n" \
"</tr>\n", \
				quant, \
				optfield##_opt[p->field].name, \
				((double) optfield##_opt[p->field].cost), \
				(quant * ((double) optfield##_opt[p->field].cost))); \
		}

void out_design(char *title, designt *p)
{
	int i;

	fprintf(cgiOut,
		"<p>\n"
		"<hr>\n"
		"<hr><h2>\n"
		"<p>\n"
		"<EM>%s (%.2f%% of best metric)</EM>\n"
		"</h2>\n"
		"<p>\n",
		title,
		(((dp+2)->metric) ?
		 (100.0 * p->metric / (dp+2)->metric) :
		 100.0));

	whatnet(p);

	fprintf(cgiOut,
		"<p>\n"
		"<CENTER>\n");

	relgraph(p);

	fprintf(cgiOut,
		"</CENTER>\n"
		"<p>\n"
		"The components used, and their costs, are summarized here:\n"
		"<p>\n"
		"<TABLE  BORDER>\n"
		"<tr>\n"
		"<TH ALIGN=LEFT>Quantity</TH>\n"
		"<TH ALIGN=LEFT>Component Description</TH>\n"
		"<TH ALIGN=LEFT>Part Price</TH>\n"
		"<TH ALIGN=LEFT>Extended Price</TH>\n"
		"</tr>\n"
		);

	tablerow(p->nics, nic, nic);
	tablerow(p->cabs, cab, cab);
	tablerow(p->sws, sw, sw);
	if (p->sw2s) {
		tablerow(p->sw2s, sw2, sw);
	}
	tablerow(p->procs, proc, proc);
	tablerow(p->moms, mom, mom);
	tablerow(p->mems, mem, mem);
	tablerow(p->disks, disk, disk);
	tablerow(p->kases, kase, kase);
	tablerow(p->racks, rack, rack);
	for(i = 0 ; i < p->bundles ; i++) {
		tablerow(p->bundle[i].n, bundle[i].id, bundle);
	}

	fprintf(cgiOut,
		"<tr>\n"
		"<td ALIGN=RIGHT COLSPAN=2>Total</td>\n"
		"<td ALIGN=RIGHT COLSPAN=2>$%.2f</td>\n"
		"</tr>\n",
		p->cost);
	fprintf(cgiOut, "</TABLE>\n");
	if (p->bundles > 0) {
		out_bundle_contents(p);
	}
#ifdef DEBUG_METRIC_DISCARD
	if (p->discard) {
		fprintf(cgiOut, "<p>this record discarded; partial metric %d\n<p>", p->discard);
	}
#endif

	notes(p);
}

void out_limits(void)
{
	int i;
	if (include_strs == 1) {
		fprintf(cgiOut, "The search included only designs with components that matched the string \"%s\".\n",
			include_str[0]);
	} else if (include_strs > 1) {
		fprintf(cgiOut, "The search included only designs in which any component matched the following strings: <br>\n<ul>\n");
		for (i = 0 ; i < include_strs ; i++) {
			fprintf(cgiOut, "<li>\"%s\"\n", include_str[i]);
		}
		fprintf(cgiOut, "</ul>\n");
	}
	if (exclude_strs == 1) {
		fprintf(cgiOut, "The search excluded all designs with components that matched the string \"%s\".\n",
			exclude_str[0]);
	} else if (exclude_strs > 1) {
		fprintf(cgiOut, "The search excluded all designs in which any component matched the following strings: <br>\n<ul>\n");
		for (i = 0 ; i < exclude_strs ; i++) {
			fprintf(cgiOut, "<li>\"%s\"\n", exclude_str[i]);
		}
		fprintf(cgiOut, "</ul>\n");
	}
}

#define BEST_DESIGN_title "Best design disallowed by string match"

void
out_html(void)
{
	char title[MAXLEN];
	register int i;
	register designt *p;

	header("fawncalc\n"
	       "<p>\n"
	       "<EM>Version %d </EM>\n", VERSION);


	/* Did we fail to find any designs? */
	if (designs_ok == 0) {
		fprintf(cgiOut,
			"<hr><h2>Design Search Failed</h2>\n"
			"<p>\n");

		out_space_stats();
		if (designs_tried == 0) {
			fprintf(cgiOut,
				"Before evaluating power requirements, every\n"
				"design was found to violate at least one of the design\n"
				"constraints specified.\n"
				"In particular, <STRONG>%s</STRONG>\n",
				whystuck());
		} else if (designs_limited > 0) {
			fprintf(cgiOut, "A total of %d possible designs were evaluated in detail.\n", designs_tried);
			out_limits();
			fprintf(cgiOut, "While no designs met the criteria you specified, had you\n"
				"not limited which components to use %d designs would have met all\n"
				"of the criteria.\n", designs_limited);
			fprintf(cgiOut, "The design with the best metric that did not\n"
				"include your limitaions is shown below\n.");
			out_design(BEST_DESIGN_title, &best_unavailable);
		} else {
			fprintf(cgiOut,
				"A total of %d possible designs were evaluated in detail,\n"
				"but no design met the power and cost constraints specified.\n"
				"In particular, <STRONG>%s</STRONG>\n",
				designs_tried,
				whystuck());
		}

		fprintf(cgiOut,
			"Please use your browser back command,\n"
			"change some parameters, and try again.\n");

		trailer();
		return;
	}


	fprintf(cgiOut,
		"<hr><h2>%d Viable Designs Created</h2>\n"
		"<p>\n",
		designs_ok);

	out_space_stats();

	fprintf(cgiOut,
		"A total of %d possible designs were evaluated in detail in %d secs,\n"
		"%d of which were found to satisfy the requirements given.\n",
		designs_tried, searchsecs,
		designs_ok);
#ifdef DEBUG_METRIC_DISCARD
	fprintf(cgiOut, "%d designs where discards.", 
		discards);
	if (bad_discard)
		fprintf(cgiOut, "%d of discarded designs should have been kept\n", bad_discard);
#endif


#ifdef DEBUG_NUM_TRIES
	fprintf(cgiOut,
		"<pre>Called e_filter %d times\n"
		"Called e_net %d times\n"
		"Called e_cab %d times\n"
		"Called e_proc %d times\n"
		"Called e_mem %d times\n"
		"Called e_kase %d times\n"
		"Called e_disk %d times\n"
		"Called e_done %d times\n</pre>", 
		num_filter, num_net, num_cab, num_proc, num_mem, num_kase, num_disk, num_done);
#endif /* DEBUG_NUM_TRIES */ 

	/* Compute minimum and maximum values... */
	minandmax();

	if (designs_limited) {
		out_limits();
	}
	if (limit && designs_limited > 0 && dp->metric < best_unavailable.metric) {
		fprintf(cgiOut, "Although at least one design matches your limited critera,\n"
			"the search found at least one design better than the best\n"
			"one using a limited component selection.\n");
		fprintf(cgiOut, "The design below is better than any design found\n"
			"with your limitations.\n<p>\n");
		out_design(BEST_DESIGN_title, &best_unavailable);
		fprintf(cgiOut, "<p><hr><p>\n<h2>Viable Designs not Disallowed by String Matching</h2>");
	}

	i = (dp - &(design[0]));

	stats();

	fprintf(cgiOut,
		"The viable designs were sorted by the metric weightings\n"
		"provided by the input form.\n");

	if (i > 1) {
		if (i > 2) {
			fprintf(cgiOut,
				"The following plot gives an overview comparison of these %d best designs:\n"
				"<p>\n"
				"<IMG SRC=\"%s\">\n"
				"<p>\n",
				i,
				plot());
		}

		if (i > MAXHTML) {
			fprintf(cgiOut,
				"Although the %d best designs were recorded,\n"
				"to keep the HTML size reasonable,\n"
				"only the %d best are detailed below.\n",
				i,
				MAXHTML);
		} else {
			fprintf(cgiOut,
				"Each of the %d best designs is detailed below.\n",
				i);
		}
	} else {
		fprintf(cgiOut,
			"The best design is displayed below.\n");
	}


	for (p=&(design[0]); p<MIN(dp, &(design[MAXHTML])); ++p) {
		sprintf(title, "Design Option %d ", p - &design[0]);
		out_design(title, p);
	}

	trailer();
}

void
out_version(void)
{
	header("fawncalc\n"
	       "<p>\n"
	       "<EM>Version %d</EM>\n", VERSION);
	fprintf(cgiOut,
		"<p>\n"
		"Form data is for the wrong version, %d, of this program.\n",
		version);
	trailer();
}
